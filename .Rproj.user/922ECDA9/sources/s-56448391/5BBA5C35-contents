
library(quantmod)
library(xts)
library(geoR)
library(mvtnorm)
library(dplyr)
library(ggplot2)
library(tidyr)


# Define variables:
# Asset_shortnames - Asset shortnames
# current_weights - current weights 
# n_days_garch - Number of garch days
# src - Data source (Others than Yahoo might not work)
# dt - Right now 1/255, might be changed to properly define time between asset prices


asset_shortnames <- c("FB","AAPL", "CAP.PA")
current_weights <- c(0, 0, 0)
n_days_garch <- 300
src <- "yahoo"
dt <- 1/255

# Get asset data
getSymbols(asset_shortnames, src=src)

# List the asset close price xts
close_prices <- lapply(asset_shortnames, function(x){asset <- get(x)
asset[,4] # Only get Close price
})


# Merge time series close prices
close_prices <- do.call(merge, close_prices)
names(close_prices) <- asset_shortnames

# Log returns
log_return <- log(close_prices/lag.xts(close_prices))

# Negative MLE
garch_mle<-function(lambda ,s ,dt ){
  # Param
  mu=lambda[1]
  beta0=lambda[2]
  beta1=lambda[3]
  beta2=lambda[4]
  alpha1=lambda[5]
  alpha2=lambda[6]
  
  # Initialisation
  l=0
  v <- integer(length(s)+1)
  v[1]=(sd(s)^2)*dt
  
  # Iterate over dt
  for (i in 1:length(s)){
    l <- l - 0.5*log(v[i]) - 0.5*(s[i] - mu*dt)^2/(v[i]*dt)
    
    if(s[i]<0){
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(s[i]-alpha1*dt)^2
    }else{
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(s[i]-alpha2*dt)^2
    }
  }
  return(-l)
}


#Define constant starting point
lambda_start <- c(0.1,0.001,0.9,0.05,0.1,0.1)
ui <- matrix(c(0,1,0,0,0,0, #beta0 LB
               0,0,1,0,0,0, #beta1 LB
               0,0,0,1,0,0, #beta2 LB
               0,0,-1,0,0,0, #beta1 UB
               0,0,0,-1,0,0, #beta2 UB
               0,0,-1,-1,0,0), #beta1+beta2<=1
             nrow = 6,
             byrow = TRUE
)
ci <- c(0,0,0,-1,-1,-1)
cov <- cov(log_return)


#Run Optimization of constants for each asset, for n_days_garch days, and list the results
garch_params <- as.data.frame(t(apply(log_return, 2, function(x) constrOptim(lambda_start,
                                                                             garch_mle, 
                                                                             grad = NULL, 
                                                                             ui = ui, 
                                                                             ci = ci, 
                                                                             s = tail(na.omit(x), n_days_garch), 
                                                                             dt = dt )$par)))
colnames(garch_params) <- c("mu", "beta0", "beta1", "beta2", "alpha1", "alpha2")


## Test 
# Iterate over returns, calculate eps and qqplot
eps <- matrix(,nrow = n_days_garch,ncol = length(asset_shortnames))
for (j in length(asset_shortnames)){
  v <- integer(n_days_garch+1)
  v[1]=(sd(log_return[,j])^2)*dt
  
  mu=garch_params[[j]][1]
  beta0=garch_params[[j]][2]
  beta1=garch_params[[j]][3]
  beta2=garch_params[[j]][4]
  alpha1=garch_params[[j]][5]
  alpha2=garch_params[[j]][6]
  
  for (i in 1:n_days_garch){
    (log_return[i,j]-mu*dt)/(sqrt(v[i]*dt))
    eps[i,j] <- (log_return[i,j]-mu*dt)/(sqrt(v[i]*dt))
    
    if(log_return[i,j]<0){
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(log_return[i]-alpha1*dt)^2
    }else{
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(log_return[i]-alpha2*dt)^2
    }
  }
}

eps <- apply(log_return, 2, function(x){
  x <- na.omit(log_return[,1])
  asset_name <- names(x)
  x$v <- (sd(x,na.rm = TRUE)^2)*dt
  x$eps <- (x[]-mu*dt)/(sqrt(x$v*dt))
  
  mu <- garch_params[asset_name,"mu"]
  beta0 <- garch_params[asset_name,"beta0"]
  beta1 <- garch_params[asset_name,"beta1"]
  beta2 <- garch_params[asset_name,"beta2"]
  alpha1 <- garch_params[asset_name,"alpha1"]
  alpha2 <- garch_params[asset_name,"alpha2"]
  
  
  x <- x %>%
    mutate()
  
  apply(na.omit(x), 1, function(y){
    if(y[1]<0){
      lead(y[2])<-beta0 + beta1*y[2] + beta2/dt*(y[1]-alpha1*dt)^2
    }else{
      lead(y[2])<-beta0 + beta1*y[2] + beta2/dt*(y[1]-alpha2*dt)^2
    }
  })
  
  
})

  for (i in 1:n_days_garch){
    (log_return[i,j]-mu*dt)/(sqrt(v[i]*dt))
    eps[i,j] <- (log_return[i,j]-mu*dt)/(sqrt(v[i]*dt))
    
    if(log_return[i,j]<0){
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(log_return[i]-alpha1*dt)^2
    }else{
      v[i+1]<-beta0 + beta1*v[i] + beta2/dt*(log_return[i]-alpha2*dt)^2
    }
  }
})

eps <- as.data.frame(eps)
names(eps) <- asset_shortnames
eps <- gather(eps, stock_shortnames, key="asset",value = "eps")
ggplot(eps, aes(sample = eps, colour = factor(asset))) + geom_qq() + geom_qq_line() + facet_wrap(. ~ asset, nrow = floor(length(asset_shortnames)))

# Covariance from eps (Not long term solution, but helps in simulating the covariances of the stochastic processes)
sigma = cov(eps)

portfolio_sim <- function(){
  
}
  
#simulate 


#nu=lambda[1]
#beta0=lambda[2]
#beta1=lambda[3]
#eta2=lambda[4]
#lpha1=lambda[5]
#alpha2=lambda[6]

#s <- log_return[,1]

